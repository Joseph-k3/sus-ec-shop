<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>在庫競合状態テスト</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
    <div style="font-family: Arial, sans-serif; padding: 20px;">
        <h1>在庫競合状態テスト</h1>
        <div id="log" style="background: #f5f5f5; padding: 15px; border-radius: 5px; white-space: pre-wrap; font-family: monospace; max-height: 400px; overflow-y: auto;"></div>
        <br>
        <button onclick="runConcurrencyTest()" style="padding: 10px 20px; background: #2c5f2d; color: white; border: none; border-radius: 5px; cursor: pointer;">
            在庫競合テストを実行
        </button>
        <button onclick="clearLog()" style="padding: 10px 20px; background: #666; color: white; border: none; border-radius: 5px; cursor: pointer; margin-left: 10px;">
            ログをクリア
        </button>
    </div>

    <script>
        // Supabaseクライアントの初期化（実際の値を設定してください）
        const supabaseUrl = 'https://hcqgfdyentwazmyikvtl.supabase.co'
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhjcWdmZHllbnR3YXpteWlrdnRsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3MjIwMDEyMjksImV4cCI6MjAzNzU3NzIyOX0.FTWWyHYCeI8DQHnOYyYGEIaL-bGCJGzHVnkx3hvhOLI'
        const supabase = window.supabase.createClient(supabaseUrl, supabaseKey)

        function log(message) {
            const logElement = document.getElementById('log')
            logElement.textContent += new Date().toLocaleTimeString() + ': ' + message + '\n'
            logElement.scrollTop = logElement.scrollHeight
        }

        function clearLog() {
            document.getElementById('log').textContent = ''
        }

        async function simulateConcurrentStockUpdate(productId, testName) {
            log(`${testName}: 同時在庫更新テスト開始`)
            
            // 2つの同時更新をシミュレート
            const update1 = performAtomicStockUpdate(productId, `${testName}-A`)
            const update2 = performAtomicStockUpdate(productId, `${testName}-B`)
            
            const results = await Promise.allSettled([update1, update2])
            
            log(`${testName}: テスト結果分析`)
            let successCount = 0
            results.forEach((result, index) => {
                const worker = index === 0 ? 'A' : 'B'
                if (result.status === 'fulfilled') {
                    log(`  ✅ ワーカー${worker}: 成功`)
                    successCount++
                } else {
                    log(`  ❌ ワーカー${worker}: 失敗 - ${result.reason}`)
                }
            })
            
            return successCount
        }

        async function performAtomicStockUpdate(productId, workerId) {
            try {
                log(`${workerId}: 在庫更新試行開始`)
                
                // 修正後のロジック：原子的在庫減少操作
                const { data: stockUpdateResult, error: stockUpdateError } = await supabase
                    .from('succulents')
                    .update({ 
                        quantity: supabase.sql`quantity - 1`  // SQLレベルでの原子的減算
                    })
                    .eq('id', productId)
                    .gte('quantity', 1)  // 在庫が1以上の場合のみ更新
                    .select('quantity, name')
                    .single()

                if (stockUpdateError) {
                    throw new Error(`在庫更新エラー: ${stockUpdateError.message}`)
                }

                // 更新された行がない場合（在庫不足）
                if (!stockUpdateResult) {
                    throw new Error('在庫が不足しています')
                }
                
                log(`${workerId}: 在庫減少成功 (商品: ${stockUpdateResult.name}, 残り: ${stockUpdateResult.quantity}個)`)
                return true
                
            } catch (error) {
                log(`${workerId}: 在庫更新失敗 - ${error.message}`)
                throw error.message
            }
        }

        async function getProductsWithLowStock() {
            const { data: products, error } = await supabase
                .from('succulents')
                .select('id, name, quantity')
                .lte('quantity', 3)
                .gt('quantity', 0)
                .order('quantity', { ascending: true })
                .limit(5)

            if (error) {
                log('商品取得エラー: ' + error.message)
                return []
            }

            return products || []
        }

        async function runConcurrencyTest() {
            try {
                log('=== 在庫競合状態テスト開始 ===')
                
                // 1. 在庫の少ない商品を取得
                const testProducts = await getProductsWithLowStock()
                
                if (testProducts.length === 0) {
                    log('テスト対象の商品が見つかりません（在庫1-3個の商品が必要）')
                    return
                }
                
                log(`テスト対象商品: ${testProducts.length}件`)
                testProducts.forEach(product => {
                    log(`  - ${product.name} (在庫: ${product.quantity}個)`)
                })
                
                // 2. 各商品に対して同時更新テストを実行
                for (const product of testProducts.slice(0, 2)) { // 最大2商品でテスト
                    if (product.quantity >= 1) {
                        log(`\n--- ${product.name} の競合テスト ---`)
                        const initialStock = product.quantity
                        
                        const successCount = await simulateConcurrentStockUpdate(product.id, product.name)
                        
                        // 最終在庫を確認
                        const { data: finalProduct } = await supabase
                            .from('succulents')
                            .select('quantity')
                            .eq('id', product.id)
                            .single()
                        
                        const expectedStock = initialStock - successCount
                        const actualStock = finalProduct?.quantity || 0
                        
                        log(`初期在庫: ${initialStock}個`)
                        log(`成功した更新: ${successCount}件`)
                        log(`期待在庫: ${expectedStock}個`)
                        log(`実際在庫: ${actualStock}個`)
                        
                        if (actualStock === expectedStock) {
                            log('✅ このテストは成功しました（在庫整合性が保たれています）')
                        } else {
                            log('❌ このテストは失敗しました（在庫に不整合があります）')
                        }
                    }
                }
                
                log('\n=== テスト完了 ===')
                log('💡 テスト結果の解釈:')
                log('  - 在庫1個の商品で2つの同時更新を行った場合')
                log('  - 成功するのは1件のみで、もう1件は「在庫不足」で失敗すべき')
                log('  - 最終在庫が期待値と一致すれば競合状態は解消されています')
                
            } catch (error) {
                log('テスト実行エラー: ' + error.message)
            }
        }
    </script>
</body>
</html>
